import os
import json
import uuid
import time
import traceback
import requests
import shutil
from fastapi import FastAPI
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Optional
from dotenv import load_dotenv

# âœ… Load .env from project root
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "..", ".env"))

from app.github_utils import create_repo, push_files_to_repo, get_pages_url, push_updated_files_to_repo
from app.generator import generate_app

# Load shared secret
SECRET = os.getenv("SECRET_KEY")
if not SECRET:
    raise Exception("âŒ SECRET not set in environment")

app = FastAPI(title="LLM Deployer", version="1.0")

# Ensure required directories exist
os.makedirs("tasks", exist_ok=True)
os.makedirs("generated_apps", exist_ok=True)

# âœ… Define the request model
class TaskRequest(BaseModel):
    email: str
    secret: str
    task: str
    round: Optional[int] = 1
    nonce: Optional[str] = None
    brief: Optional[str] = None
    checks: Optional[List[str]] = None
    evaluation_url: Optional[str] = None
    attachments: Optional[List[dict]] = None


def post_evaluation(payload: dict, max_retries: int = 5):
    """
    POST JSON to evaluation_url with exponential backoff on failure.
    """
    url = payload.get("evaluation_url")
    if not url:
        print("âš ï¸ No evaluation_url provided, skipping POST.")
        return

    delay = 1
    for attempt in range(max_retries):
        try:
            response = requests.post(url, json=payload, headers={"Content-Type": "application/json"}, timeout=10)
            if response.status_code == 200:
                print(f"âœ… Evaluation POST successful to {url}")
                return
            else:
                print(f"âš ï¸ Evaluation POST failed with status {response.status_code}, retrying in {delay}s...")
        except Exception as e:
            print(f"âš ï¸ Error posting evaluation: {e}, retrying in {delay}s...")
        time.sleep(delay)
        delay *= 2
    print("âŒ Failed to POST evaluation after retries.")


@app.post("/task")
async def receive_task(data: TaskRequest):
    """
    Handles both Round 1 and Round 2 of the LLM Deployment Project.
    """
    try:
        # âœ… Step 0: Verify secret
        if data.secret != SECRET:
            return JSONResponse(status_code=403, content={"status": "error", "message": "Invalid secret"})

        # Convert model to dict
        data_dict = data.dict()
        nonce = data_dict.get("nonce") or str(uuid.uuid4())
        task_id = f"{data_dict['task']}-{nonce}"
        task_file = os.path.join("tasks", f"{task_id}.json")
        app_folder = os.path.join("generated_apps", task_id)

        # === ROUND 1 ===
        if data.round == 1:
            # âœ… Step 1: Save task JSON locally
            with open(task_file, "w", encoding="utf-8") as f:
                json.dump(data_dict, f, indent=2)
            print(f"ğŸ“ [Round 1] Task saved at {task_file}")

            # âœ… Step 2: Generate minimal app
            folder_path = generate_app(data_dict)
            print(f"ğŸ“ [Round 1] App generated at {folder_path}")

            # âœ… Step 3: Create GitHub repo
            repo_url = create_repo(repo_name=task_id, description="Generated by LLM Deployer")
            print(f"ğŸ“¡ [Round 1] Repo created at {repo_url}")

            # âœ… Step 4: Push files to repo and get commit SHA
            repo_name = repo_url.split("/")[-1].replace(".git", "")
            commit_sha = push_files_to_repo(repo_name, folder_path)
            print(f"ğŸ“¤ [Round 1] Files pushed to {repo_name}, last commit SHA: {commit_sha}")

            # âœ… Step 5: Get GitHub Pages URL
            pages_url = get_pages_url(repo_name)
            print(f"ğŸŒ [Round 1] GitHub Pages URL: {pages_url}")

            # âœ… Step 6: Store repo details for Round 2 usage
            data_dict["repo_url"] = repo_url
            data_dict["commit_sha"] = commit_sha
            data_dict["pages_url"] = pages_url
            with open(task_file, "w", encoding="utf-8") as f:
                json.dump(data_dict, f, indent=2)

        # === ROUND 2 ===
        else:
            print(f"â™»ï¸ [Round 2] Updating existing repo for task {task_id}")

            # Load round 1 task info
            if not os.path.exists(task_file):
                return JSONResponse(status_code=400, content={"error": "No previous task found for round 2"})

            with open(task_file, "r", encoding="utf-8") as f:
                old_task = json.load(f)

            repo_url = old_task.get("repo_url")
            if not repo_url:
                return JSONResponse(status_code=400, content={"error": "No repo URL found from round 1"})

            repo_name = repo_url.split("/")[-1].replace(".git", "")

            # Clean app folder (except .git)
            if os.path.exists(app_folder):
                for item in os.listdir(app_folder):
                    if item == ".git":
                        continue
                    item_path = os.path.join(app_folder, item)
                    if os.path.isfile(item_path):
                        os.remove(item_path)
                    else:
                        shutil.rmtree(item_path)

            # Re-generate app with updated brief
            folder_path = generate_app(data_dict)
            print(f"ğŸ“ [Round 2] App regenerated at {folder_path}")

            # Push updated files to the same repo
            commit_sha = push_updated_files_to_repo(repo_name, folder_path)
            pages_url = get_pages_url(repo_name)
            print(f"ğŸ“¤ [Round 2] Updated repo pushed. New commit SHA: {commit_sha}")

            # Update task file with new info
            old_task.update(data_dict)
            old_task["commit_sha"] = commit_sha
            old_task["pages_url"] = pages_url
            with open(task_file, "w", encoding="utf-8") as f:
                json.dump(old_task, f, indent=2)

        # âœ… Step 7: POST to evaluation server
        evaluation_payload = {
            "email": data.email,
            "secret": data.secret,
            "task": data.task,
            "round": data.round,
            "nonce": nonce,
            "repo_url": repo_url,
            "commit_sha": commit_sha,
            "pages_url": pages_url,
            "evaluation_url": data.evaluation_url
        }
        post_evaluation(evaluation_payload)

        return {
            "status": "success",
            "task_id": task_id,
            "round": data.round,
            "repo_url": repo_url,
            "commit_sha": commit_sha,
            "pages_url": pages_url
        }

    except Exception as e:
        tb = traceback.format_exc()
        print("âŒ Error in /task:\n", tb)
        return JSONResponse(
            status_code=500,
            content={
                "status": "error",
                "message": "Failed to process task",
                "error_type": str(type(e)),
                "error_details": str(e),
                "traceback": tb
            }
        )


@app.post("/evaluation")
async def evaluation(payload: dict):
    print("ğŸ“¥ Evaluation callback received:", payload)
    return {"status": "ok"}


@app.get("/")
def root():
    return {"message": "ğŸš€ LLM Deployer is running"}
